"""Fix node implementation using Claude Code."""

import json
import os
import re
import secrets
import subprocess
import sys
import tempfile
from pathlib import Path

from langsmith import traceable

from beneissue.graph.state import IssueState
from beneissue.integrations.github import clone_repo
from beneissue.nodes.schemas import FixResult


def _log(message: str, level: str = "info") -> None:
    """Log message to stderr for GitHub Actions visibility."""
    prefix = {"info": "â„¹ï¸", "success": "âœ…", "error": "âŒ", "warning": "âš ï¸"}.get(level, "")
    print(f"{prefix} [fix] {message}", file=sys.stderr, flush=True)

# Load prompt from file
PROMPT_PATH = Path(__file__).parent.parent / "prompts" / "fix.md"
FIX_PROMPT = PROMPT_PATH.read_text()

# Timeout for Claude Code execution (5 minutes)
CLAUDE_CODE_TIMEOUT = 300


def _parse_fix_output(output: str) -> FixResult | None:
    """Parse Claude Code output for FixResult JSON."""
    # Try markdown code block first, then raw JSON
    patterns = [
        r"```json\s*(\{[^`]*\})\s*```",  # ```json {...} ```
        r'(\{\s*"success"\s*:[^}]*\})',  # Raw JSON with "success" key
    ]

    for pattern in patterns:
        match = re.search(pattern, output, re.DOTALL)
        if match:
            try:
                data = json.loads(match.group(1))
                return FixResult(**data)
            except (json.JSONDecodeError, ValueError):
                continue

    return None


def _build_fix_prompt(state: IssueState) -> str:
    """Build the fix prompt for Claude Code."""
    affected_files = state.get("affected_files", [])
    affected_files_str = (
        "\n".join(f"- {f}" for f in affected_files)
        if affected_files
        else "No specific files identified"
    )

    return FIX_PROMPT.format(
        issue_number=state["issue_number"],
        issue_title=state["issue_title"],
        analysis_summary=state.get("analysis_summary", "No analysis available"),
        affected_files=affected_files_str,
    )


def _run_git(repo_path: str, *args: str) -> subprocess.CompletedProcess:
    """Run a git command in the repo directory."""
    return subprocess.run(
        ["git", *args],
        capture_output=True,
        cwd=repo_path,
        timeout=60,
    )


def _create_pr(
    repo_path: str, state: IssueState, fix_result: FixResult | None, branch_name: str
) -> str | None:
    """Create a PR using gh CLI and return the PR URL."""
    issue_number = state["issue_number"]
    repo = state["repo"]

    # Use fix result or fall back to defaults
    pr_title = (
        fix_result.title
        if fix_result and fix_result.title
        else f"Fix #{issue_number}: {state['issue_title']}"
    )
    pr_description = (
        fix_result.description
        if fix_result and fix_result.description
        else state.get("analysis_summary", "No analysis available")
    )
    ai_disclaimer = "ðŸ¤– *This was generated by AI and may be inaccurate or inappropriate. Please review carefully!*"
    pr_body = f"{pr_description}\n\n{ai_disclaimer}\n\n---\nCloses #{issue_number}"

    # Create PR using gh CLI
    # Note: --repo is required when running from a cloned temp directory
    result = subprocess.run(
        [
            "gh",
            "pr",
            "create",
            "--repo",
            repo,
            "--title",
            pr_title,
            "--body",
            pr_body,
            "--base",
            "main",
            "--head",
            branch_name,
        ],
        capture_output=True,
        cwd=repo_path,
        timeout=60,
        env={
            **os.environ,
            "GH_TOKEN": os.environ.get("GITHUB_TOKEN", ""),
        },
    )

    if result.returncode == 0:
        # gh pr create outputs the PR URL
        return result.stdout.decode().strip()
    # Return error message for debugging
    stderr = result.stderr.decode() if result.stderr else "Unknown error"
    return f"ERROR:{stderr[:200]}"


@traceable(name="claude_code_fix", run_type="chain")
def fix_node(state: IssueState) -> dict:
    """Execute fix using Claude Code CLI."""
    prompt = _build_fix_prompt(state)
    issue_number = state["issue_number"]

    _log(f"Starting fix for issue #{issue_number}")

    # Create temporary directory for the repo
    with tempfile.TemporaryDirectory() as temp_dir:
        repo_path = os.path.join(temp_dir, "repo")

        # Clone the repository
        _log(f"Cloning repository {state['repo']}...")
        if not clone_repo(state["repo"], repo_path):
            _log("Failed to clone repository", "error")
            return {
                "fix_success": False,
                "fix_error": "Failed to clone repository",
                "labels_to_add": ["fix/failed"],
            }

        try:
            _log("Running Claude Code to analyze and fix...")
            # Run Claude Code using npx (no global installation required)
            result = subprocess.run(
                [
                    "npx",
                    "-y",
                    "@anthropic-ai/claude-code",
                    "-p",
                    prompt,
                    "--allowedTools",
                    "Read,Glob,Grep,Edit,Write,Bash",
                    "--verbose",
                ],
                capture_output=True,
                timeout=CLAUDE_CODE_TIMEOUT,
                cwd=repo_path,
                env={
                    **os.environ,
                    "ANTHROPIC_API_KEY": os.environ.get("ANTHROPIC_API_KEY", ""),
                },
            )

            # Log Claude Code output
            stdout = result.stdout.decode() if result.stdout else ""
            stderr = result.stderr.decode() if result.stderr else ""

            if stdout:
                _log("=== Claude Code Output ===")
                print(stdout, file=sys.stderr, flush=True)
                _log("=== End Claude Code Output ===")

            if result.returncode != 0:
                _log(f"Claude Code failed with return code {result.returncode}", "error")
                if stderr:
                    _log(f"stderr: {stderr[:500]}", "error")
                return {
                    "fix_success": False,
                    "fix_error": stderr[:500],
                    "labels_to_add": ["fix/manual-required"],
                }

            # Parse fix output
            fix_result = _parse_fix_output(stdout)

            if fix_result:
                _log(f"Fix result: success={fix_result.success}, title={fix_result.title}")
            else:
                _log("Could not parse structured fix result from output", "warning")

            # Check if fix reported failure
            if fix_result and not fix_result.success:
                _log(f"Fix reported failure: {fix_result.error}", "error")
                return {
                    "fix_success": False,
                    "fix_error": fix_result.error or "Fix reported failure",
                    "labels_to_add": ["fix/manual-required"],
                }

            # Check if there are changes
            status_result = _run_git(repo_path, "status", "--porcelain")
            changes = status_result.stdout.decode().strip()
            if not changes:
                _log("No changes were made by Claude Code", "warning")
                return {
                    "fix_success": False,
                    "fix_error": "No changes were made",
                    "labels_to_add": ["fix/manual-required"],
                }

            _log(f"Changes detected:\n{changes}")

            # Create branch with random suffix to avoid conflicts
            random_suffix = secrets.token_hex(3)
            branch_name = f"fix/issue-{issue_number}-{random_suffix}"
            _run_git(repo_path, "checkout", "-b", branch_name)
            _log(f"Created branch: {branch_name}")

            # Build commit message from fix result or fallback
            commit_title = (
                fix_result.title
                if fix_result and fix_result.title
                else f"fix: resolve issue #{issue_number}"
            )
            commit_body = (
                f"{fix_result.description}\n\n" if fix_result and fix_result.description else ""
            )
            commit_msg = f"{commit_title}\n\n{commit_body}Closes #{issue_number}\nCo-Authored-By: Claude <noreply@anthropic.com>"

            # Configure git user for this commit (github-actions bot)
            _run_git(repo_path, "config", "user.name", "github-actions[bot]")
            _run_git(repo_path, "config", "user.email", "github-actions[bot]@users.noreply.github.com")

            # Commit changes
            _run_git(repo_path, "add", "-A")
            _run_git(repo_path, "commit", "-m", commit_msg)
            _log(f"Committed with message: {commit_title}")

            # Push branch
            _log(f"Pushing branch {branch_name}...")
            push_result = _run_git(repo_path, "push", "-u", "origin", branch_name)
            if push_result.returncode != 0:
                push_error = push_result.stderr.decode()[:200]
                _log(f"Failed to push: {push_error}", "error")
                return {
                    "fix_success": False,
                    "fix_error": f"Failed to push: {push_error}",
                    "labels_to_add": ["fix/manual-required"],
                }

            # Create PR
            _log("Creating pull request...")
            pr_url = _create_pr(repo_path, state, fix_result, branch_name)

            if pr_url and not pr_url.startswith("ERROR:"):
                _log(f"PR created: {pr_url}", "success")
                return {
                    "fix_success": True,
                    "pr_url": pr_url,
                    "labels_to_remove": ["fix/auto-eligible"],
                    "labels_to_add": ["fix/completed"],
                }
            else:
                error_msg = pr_url[6:] if pr_url and pr_url.startswith("ERROR:") else "Failed to create PR"
                _log(f"Failed to create PR: {error_msg}", "error")
                return {
                    "fix_success": False,
                    "fix_error": error_msg,
                    "labels_to_add": ["fix/manual-required"],
                }

        except subprocess.TimeoutExpired:
            _log(f"Timeout after {CLAUDE_CODE_TIMEOUT} seconds", "error")
            return {
                "fix_success": False,
                "fix_error": f"Timeout after {CLAUDE_CODE_TIMEOUT} seconds",
                "labels_to_add": ["fix/manual-required"],
            }
        except FileNotFoundError:
            _log("npx not found. Ensure Node.js is installed.", "error")
            return {
                "fix_success": False,
                "fix_error": "npx not found. Ensure Node.js is installed.",
                "labels_to_add": ["fix/manual-required"],
            }
        except Exception as e:
            _log(f"Unexpected error: {e}", "error")
            return {
                "fix_success": False,
                "fix_error": str(e)[:500],
                "labels_to_add": ["fix/manual-required"],
            }
